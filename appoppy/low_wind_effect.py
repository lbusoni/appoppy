import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import os
from poppy.poppy_core import ArrayOpticalElement
import astropy.units as u


class LowWindEffectLoader():

    def __init__(self, wind_speed):
        # Definition of frames and timestamps
        self._frameTimes = self._readFrameTime('frameTime_definition.txt')
        # Definitions of grid coordinates
        self._xvals = np.load('xvals.npy') + 0.0125
        self._yvals = np.load('yvals.npy')

        # matrix for masking out the structure
        self._probeDef = np.load('probeDef_npf.npy')
        self._mask = (self._probeDef == 0).astype(bool)
        self.wind_speed = wind_speed

        self.time_step = 0.2013
        self.pixelscale = 0.035

        if wind_speed == 0.5:
            fname = 'allFramesOPD_0p5mps.npy'
            scaling_factor = 2.7
        elif wind_speed == 1.0:
            fname = 'allFramesOPD_1p0mps.npy'
            scaling_factor = 1.74
        else:
            raise ValueError('Unsupported wind speed value %g' % wind_speed)

        # Numpy array has 3 dimensions: [time, xID, yID], masked with mask
        opd = np.load(fname)
        self._opdAll = np.ma.array(
            [np.ma.masked_where(self._mask, scaling_factor * fr) for fr in opd]
        )
        self._opdAvg = np.sum(self._opdAll, axis=0) / self._opdAll.shape[0]

    def opd_cube(self):
        return self._opdAll

    def opd_average(self):
        # compute time averages of OPD
        return self._opdAvg

    def mask(self):
        return self._mask

    def _readFrameTime(self, fname):
        f = open(fname)
        ls = f.readlines()
        f.close()
        data = {}
        for l in ls[1:]:
            ld = l.split(',')
            data[int(ld[0])] = float(ld[1])
        return data

    def plotAvgSlice(self, opd, jpg_dir='./', title='', rms=False, vmax=5):

        fig, ax = plt.subplots(figsize=(9, 8))

        opdM = np.ma.masked_where(
            self._probeDef == 0, opd)  # Mask out structure

        cmap = matplotlib.cm.nipy_spectral  # set colormap

        cmap.set_bad('grey')  # Color of structure

        plt.imshow(opdM,
                   cmap=cmap,
                   vmin=0,
                   vmax=vmax,
                   interpolation='none',
                   extent=[
                       self._yvals[0], self._yvals[-1],
                       self._xvals[0], self._xvals[-1]])
        clb = plt.colorbar(pad=0.05, fraction=0.02)
        clb.set_label('OPD [Î¼m]', labelpad=-40, y=1.1, rotation=0)

        #ax.text(0.05, 1.025, 'Time = %0.2f [s]' %time, transform=ax.transAxes)
        ax.text(0.35, 1.025, title, transform=ax.transAxes)
        ax.set_xlabel('y [m]')
        ax.set_ylabel('x [m]')
        plt.tight_layout()

        if False:
            fname = os.path.join(jpg_dir, 'fig_avgFrame.png')
            plt.savefig(fname, dpi=600)
            plt.close()
        else:
            plt.show()


class LowWindEffectWavefront(ArrayOpticalElement):
    '''
    Return an OpticalElement whose opd represents the Low Wind Effect
    simulations from Ron Holzloehner and Christophe Verinaud

    Data consists of 99 frames sampled at 0.2s of optical path difference
    generated by CFD simulations.

    Selected data are available in the shared gdrive
    "MORFEO-OAA/Petalometro Ciao Ciao/PowerFLOW OPD".

    The user must copy the package from gdrive
    in appoppy/data and pip install again to copy the data in the proper folder.


    Parameters
    ----------
    wind_speed: float
        either 0.5 or 1 (m/s)
    start_from: int (optional, default=0)
        first frame to use
    step: int (optional, default=0)
        how many frames to jump at each get_opd call
    average_on: int (optional, default=1)
        how many frames to average on each get_opd call

    Example
    -------
    LowWindEffectWavefront(start_from=10, step=0, average_on=1) returns always
    the 10th frame

    LowWindEffectWavefront(start_from=10, step=10, average_on=3) yields
    (mean(10:13), mean(20:23), mean(30:33)...)
    '''
    _START_FROM = 0

    def __init__(self,
                 wind_speed,
                 start_from=None,
                 step=0,
                 average_on=1,
                 **kwargs):
        self._lwe = LowWindEffectLoader(wind_speed)
        self._pxscale = self._lwe.pixelscale * u.m / u.pixel
        self._nframes = self._lwe.opd_cube().shape[0]

        if start_from is None:
            self._start_from = self._START_FROM
        else:
            self._start_from = start_from
        self._step = step
        self._average_on = average_on
        self._step_idx = np.maximum(
            0, np.minimum(self._start_from, self._nframes))
        self.amplitude = (~self._cube[self._START_FROM].mask).astype(int)
        super(LowWindEffectWavefront, self).__init__(
            transmission=self.amplitude, pixelscale=self._pxscale, **kwargs)

    @property
    def _cube(self):
        return self._lwe.opd_cube()

    @property
    def time_step(self):
        return self._lwe.time_step

    @property
    def shape(self):
        return self._lwe.opd_cube().shape

    def set_step_idx(self, step_idx):
        self._step_idx = step_idx

    def get_opd(self, wave):
        first = self._step_idx
        last = np.minimum(self._step_idx + self._average_on, self._nframes)
        self.opd = np.mean(self._cube[first:last].data, axis=0) * 1e-6
        # self._remove_global_piston()
        self._step_idx = (self._step_idx + self._step) % self._nframes
        return self.opd

    def _remove_global_piston(self):
        self.opd -= self.opd.mean()

    def as_optical_element(self, step=None, average_on=1):
        if step is None:
            step = self._step_idx
            self._step_idx += average_on
        opd = np.mean(self._cube[step:step + average_on].data, axis=0) * 1e-6
        transmission = (~self._cube[step].mask).astype(int)
        return ArrayOpticalElement(
            opd=opd,
            transmission=transmission,
            pixelscale=self._pxscale)
