import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import os
from poppy.poppy_core import ArrayOpticalElement
import astropy.units as u
from appoppy.package_data import data_root_dir


class LowWindEffectLoader():

    def __init__(self, wind_speed):
        root_folder = os.path.join(data_root_dir(),
                                   'PowerFLOW_OPD_data_Jul22')
        # Definition of frames and timestamps
        self._frameTimes = self._read_frame_time(
            os.path.join(root_folder, 'frameTime_definition.txt'))
        # Definitions of grid coordinates
        self._xvals = np.load(os.path.join(root_folder, 'xvals.npy')) + 0.0125
        self._yvals = np.load(os.path.join(root_folder, 'yvals.npy'))

        # matrix for masking out the structure
        self._probeDef = np.load(os.path.join(root_folder, 'probeDef_npf.npy'))
        self._mask = (self._probeDef == 0).astype(bool)
        self.wind_speed = wind_speed

        self.time_step = 0.2013
        self.pixelscale = 0.035

        if wind_speed is None:
            fname = os.path.join(root_folder, 'allFramesOPD_0p5mps.npy')
            scaling_factor = 0
        elif wind_speed == 0.5:
            fname = os.path.join(root_folder, 'allFramesOPD_0p5mps.npy')
            scaling_factor = 2.7
        elif wind_speed == 1.0:
            fname = os.path.join(root_folder, 'allFramesOPD_1p0mps.npy')
            scaling_factor = 1.74
        else:
            raise ValueError('Unsupported wind speed value %g' % wind_speed)

        # Numpy array has 3 dimensions: [time, xID, yID], masked with mask
        opd = np.load(fname)
        self._opdAll = np.ma.array(
            [np.ma.masked_where(self._mask, scaling_factor * fr) for fr in opd]
        )
        self._opdAvg = None

    def opd_cube(self):
        return self._opdAll

    def opd_average(self):
        if self._opdAvg is None:
            # compute time averages of OPD
            self._opdAvg = np.sum(self._opdAll, axis=0) / self._opdAll.shape[0]
        return self._opdAvg

    def mask(self):
        return self._mask

    def _read_frame_time(self, fname):
        f = open(fname)
        ls = f.readlines()
        f.close()
        data = {}
        for l in ls[1:]:
            ld = l.split(',')
            data[int(ld[0])] = float(ld[1])
        return data

    def plot_slice(self, opd, title='', vmax=5):

        fig, ax = plt.subplots(figsize=(9, 8))

        opdM = np.ma.masked_where(
            self._probeDef == 0, opd)  # Mask out structure

        cmap = matplotlib.cm.nipy_spectral  # set colormap

        cmap.set_bad('grey')  # Color of structure

        plt.imshow(opdM,
                   cmap=cmap,
                   vmin=0,
                   vmax=vmax,
                   interpolation='none',
                   extent=[
                       self._yvals[0], self._yvals[-1],
                       self._xvals[0], self._xvals[-1]])
        clb = plt.colorbar(pad=0.05, fraction=0.02)
        clb.set_label('OPD [Î¼m]', labelpad=-40, y=1.1, rotation=0)

        ax.text(0.35, 1.025, title, transform=ax.transAxes)
        ax.set_xlabel('y [m]')
        ax.set_ylabel('x [m]')
        plt.tight_layout()

        plt.show()


class LowWindEffectWavefront(ArrayOpticalElement):
    '''
    Return an OpticalElement whose opd represents the Low Wind Effect
    simulations from Ron Holzloehner and Christophe Verinaud

    Data consists of 99 frames sampled at 0.2s of optical path difference
    generated by CFD simulations.

    Selected data are available in the shared gdrive
    "MORFEO-OAA/Petalometro Ciao Ciao/PowerFLOW OPD".

    The user must copy from gdrive the files probeDef_npf.npy,
    allFramesOPD_0p5mps.npy and allFramesOPD_1p0mps.npy (that are too large
    to be committed in the github repository) 
    in appoppy/data/PowerFLOW_OPD_data_Jul22

    and pip install again to copy the data in the proper installation folder.

    OPD cube are trimmed to have the telescope pupil centered on the central
    pixel of the array

    Parameters
    ----------
    wind_speed: float or None
        Must be in (0, 0.5, 1) (m/s). None returns null opd
    start_from: int (optional, default=0)
        first frame to use
    step: int (optional, default=0)
        how many frames to jump at each get_opd call
    average_on: int (optional, default=1)
        how many frames to average on each get_opd call

    Example
    -------
    LowWindEffectWavefront(start_from=10, step=0, average_on=1) returns always
    the 10th frame

    LowWindEffectWavefront(start_from=10, step=10, average_on=3) yields
    (mean(10:13), mean(20:23), mean(30:33)...)
    '''
    _START_FROM = 0

    def __init__(self,
                 wind_speed,
                 start_from=None,
                 step=0,
                 average_on=1,
                 **kwargs):
        self._lwe = LowWindEffectLoader(wind_speed)
        self._pxscale = self._lwe.pixelscale * u.m / u.pixel
        self._nframes = self._lwe.opd_cube().shape[0]

        assert self._lwe._xvals[571] == 0, \
            'Fatal error. Expect pixel 571 to have xcoord=0'
        self._cube = self._lwe.opd_cube()[:, 0:571 * 2, :]

        if start_from is None:
            self._start_from = self._START_FROM
        else:
            self._start_from = start_from
        self._step = step
        self._average_on = average_on
        self._step_idx = np.maximum(
            0, np.minimum(self._start_from, self._nframes))
        self.amplitude = (~self._cube[self._START_FROM].mask).astype(int)
        super(LowWindEffectWavefront, self).__init__(
            transmission=self.amplitude, pixelscale=self._pxscale, **kwargs)

    @property
    def time_step(self):
        return self._lwe.time_step

    @property
    def shape(self):
        return self._lwe.opd_cube().shape

    def set_step_idx(self, step_idx):
        self._step_idx = step_idx

    def get_opd(self, wave):
        first = self._step_idx
        last = np.minimum(self._step_idx + self._average_on, self._nframes)
        self.opd = np.mean(self._cube[first:last].data, axis=0) * 1e-6
        # self._remove_global_piston()
        self._step_idx = (self._step_idx + self._step) % self._nframes
        return self.opd

    def _remove_global_piston(self):
        self.opd -= self.opd.mean()

    def as_optical_element(self, step=None, average_on=1):
        if step is None:
            step = self._step_idx
            self._step_idx += average_on
        opd = np.mean(self._cube[step:step + average_on].data, axis=0) * 1e-6
        transmission = (~self._cube[step].mask).astype(int)
        return ArrayOpticalElement(
            opd=opd,
            transmission=transmission,
            pixelscale=self._pxscale)
